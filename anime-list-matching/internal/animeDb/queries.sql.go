// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package animeDb

import (
	"context"
	"encoding/json"
)

const cacheAnimeResult = `-- name: CacheAnimeResult :one
INSERT INTO animeResultCache (
  id, response
) VALUES (
  $1, $2
)
ON CONFLICT(id) DO UPDATE SET response = EXCLUDED.response
RETURNING id, response
`

type CacheAnimeResultParams struct {
	ID       int32
	Response json.RawMessage
}

func (q *Queries) CacheAnimeResult(ctx context.Context, arg CacheAnimeResultParams) (Animeresultcache, error) {
	row := q.db.QueryRowContext(ctx, cacheAnimeResult, arg.ID, arg.Response)
	var i Animeresultcache
	err := row.Scan(&i.ID, &i.Response)
	return i, err
}

const cacheAnimeSearch = `-- name: CacheAnimeSearch :one
INSERT INTO animeSearchCache (
  searchTerm, response
) VALUES (
  $1, $2
)
ON CONFLICT(id) DO UPDATE SET response = EXCLUDED.response
RETURNING id, searchterm, response
`

type CacheAnimeSearchParams struct {
	Searchterm string
	Response   json.RawMessage
}

func (q *Queries) CacheAnimeSearch(ctx context.Context, arg CacheAnimeSearchParams) (Animesearchcache, error) {
	row := q.db.QueryRowContext(ctx, cacheAnimeSearch, arg.Searchterm, arg.Response)
	var i Animesearchcache
	err := row.Scan(&i.ID, &i.Searchterm, &i.Response)
	return i, err
}

const getCachedAnimeResult = `-- name: GetCachedAnimeResult :one
SELECT response FROM animeResultCache WHERE id = $1
`

func (q *Queries) GetCachedAnimeResult(ctx context.Context, id int32) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getCachedAnimeResult, id)
	var response json.RawMessage
	err := row.Scan(&response)
	return response, err
}

const getCachedAnimeSearchResult = `-- name: GetCachedAnimeSearchResult :one
SELECT response FROM animeSearchCache WHERE searchTerm = $1
`

func (q *Queries) GetCachedAnimeSearchResult(ctx context.Context, searchterm string) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getCachedAnimeSearchResult, searchterm)
	var response json.RawMessage
	err := row.Scan(&response)
	return response, err
}

const saveMapping = `-- name: SaveMapping :exec
INSERT INTO animeMapping (
  anilistId,
  plexSeriesId
) VALUES (
  $1, $2
)
`

type SaveMappingParams struct {
	Anilistid    int32
	Plexseriesid string
}

func (q *Queries) SaveMapping(ctx context.Context, arg SaveMappingParams) error {
	_, err := q.db.ExecContext(ctx, saveMapping, arg.Anilistid, arg.Plexseriesid)
	return err
}

const getMappings = `-- name: getMappings :many
SELECT id, anilistid, plexseriesid FROM animeMapping WHERE plexSeriesId = $1
`

func (q *Queries) getMappings(ctx context.Context, plexseriesid string) ([]Animemapping, error) {
	rows, err := q.db.QueryContext(ctx, getMappings, plexseriesid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Animemapping
	for rows.Next() {
		var i Animemapping
		if err := rows.Scan(&i.ID, &i.Anilistid, &i.Plexseriesid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
